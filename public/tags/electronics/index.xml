<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Electronics on Abdullah Salameh&#39;s Blog</title>
    <link>/tags/electronics/</link>
    <description>Recent content in Electronics on Abdullah Salameh&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 09 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="/tags/electronics/index.xml" rel="self" type="application/rss+xml" /><icon>/logo.svg</icon>
    
    
    <item>
      <title>PID Controller</title>
      <link>/posts/pid-controller/</link>
      <pubDate>Wed, 09 Apr 2025 00:00:00 +0000</pubDate>
      
      <guid>/posts/pid-controller/</guid>
      <description><![CDATA[<p>PID controllers are the most common control method in modern control systems. They form the foundation of feedback control architecture that engineers rely on across countless applications. In this post, we&rsquo;ll explore how these controllers work, breaking down each component to understand their individual contributions and how they function together as a unified system.</p>
<h2 id="the-basic-feedback-control-concept">The Basic Feedback Control Concept</h2>
<p><img src="/images/Pasted%20image%2020250409062703.png" alt="Image Description"></p>
<p>Let&rsquo;s start by understanding the standard feedback control architecture. In this setup:</p>
<ul>
<li>The plant (the system being controlled) produces an output signal (y)</li>
<li>We take this plant output signal and compare it with our desired input/reference signal (r)</li>
<li>If these two signals don&rsquo;t match, we calculate the difference between them, creating our error signal (e)</li>
<li>The controller examines this error signal and computes a control signal (u)</li>
<li>This control signal is then applied to the plant to adjust its behavior</li>
</ul>
<p>This feedback loop continuously works to bring the actual output closer to our desired reference.</p>
<h2 id="starting-simple-proportional-control">Starting Simple: Proportional Control</h2>
<p>When designing a controller, we should first consider the simplest approach that might work. What&rsquo;s simpler than taking the error and multiplying it by a constant gain value?</p>
<p><img src="/images/Pasted%20image%2020250409062649.png" alt="Image Description"></p>
<p>This gives us our first control law:</p>
<p>$$u(t) = K \cdot e(t)$$</p>
<p>This is called proportional control - the &ldquo;P&rdquo; in PID. It simply takes the error and multiplies it by a static gain K to compute the control signal. While basic, this approach forms the foundation upon which we&rsquo;ll build our more sophisticated controller.</p>
<h2 id="expanding-to-pid-control">Expanding to PID Control</h2>
<p>PID enhances the basic proportional concept by adding two additional terms, making the control more responsive and accurate:</p>
<p><img src="/images/Pasted%20image%2020250409062601.png" alt="Image Description"></p>
<p>The complete PID control law is:</p>
<p>$$u(t) = K_p \cdot e(t) + K_i \int_{0}^{t} e(\tau) d\tau + K_d \frac{de(t)}{dt}$$</p>
<p>These three components are:</p>
<ul>
<li><strong>Proportional term</strong>: $K_p \cdot e(t)$</li>
<li><strong>Integral term</strong>: $K_i \int_{0}^{t} e(\tau) d\tau$</li>
<li><strong>Derivative term</strong>: $K_d \frac{de(t)}{dt}$</li>
</ul>
<p>The PID controller&rsquo;s elegance lies in its simplicity. When an error signal reaches the controller, it splits into these three paths. Each path processes the error differently, and the results are summed to produce the final control signal.</p>
<p>Let&rsquo;s examine each component individually to understand its behavior and purpose.</p>
<h2 id="proportional-control-explained">Proportional Control Explained</h2>
<p><img src="/images/Pasted%20image%2020250410154931.png" alt="Image Description">
<img src="/images/Pasted%20image%2020250410162758.png" alt="Image Description"></p>
<p>Consider what happens when we have only proportional control:</p>
<p>When the error is zero (meaning our output matches our reference perfectly), the control output is also zero, regardless of what gain value we&rsquo;ve chosen. The system is in balance.</p>
<p>Now imagine what happens when we introduce a step change in our reference signal:</p>
<ol>
<li>The error jumps up instantly (to point A in our diagram)</li>
<li>The proportional control signal also jumps instantly to $A \times K_p$</li>
</ol>
<p>This immediate response is the key advantage of proportional control - it reacts instantaneously with no dynamics involved. When the controller &ldquo;sees&rdquo; a large error, it applies a large corrective signal to push the system back toward our desired state.</p>
<p>As the system begins to respond, the error decreases. However, as the error gets smaller, the control signal also becomes weaker. This creates an interesting challenge: the control signal gets progressively weaker as we approach our target. At some point, the control signal may become too weak to overcome system friction or other limitations.</p>
<p>For example, if we&rsquo;re controlling a motor to reach a specific angle, each reduction in error leads to a proportional reduction in the voltage applied to the motor. Eventually, we might reach a point where the applied voltage is too small to overcome the motor&rsquo;s internal resistance and friction. This results in a steady-state error - the system stabilizes at a point close to, but not exactly at, our target.</p>
<h2 id="integral-control-explained">Integral Control Explained</h2>
<p><img src="/images/Pasted%20image%2020250413212833.png" alt="Image Description"></p>
<p><img src="/images/Pasted%20image%2020250413214953.png" alt="Image Description"></p>
<p>Now let&rsquo;s examine just the integral term: $K_i \int_{0}^{t} e(\tau) d\tau$</p>
<p>This term accumulates the error over time, multiplying the result by the gain factor $K_i$.</p>
<p>When a step change occurs in our system:</p>
<ol>
<li>Initially, the integral control signal is small. Even though the error might be large, the controller hasn&rsquo;t had much time to accumulate this error (the area under the curve is small at point X₁).</li>
<li>As time passes (to point X₂), the integral accumulates more area under the error curve, increasing the control signal strength. The controller pushes harder the longer an error persists.</li>
<li>By point X₃, when the error finally reaches zero, the integral has accumulated a significant &ldquo;history&rdquo; of error.</li>
</ol>
<p>What makes integral control interesting is what happens next. Even when the error becomes zero at X₃, the integral control doesn&rsquo;t immediately stop - it continues pushing in the same direction. This causes the system to overshoot the target.</p>
<p>As the error goes negative after overshooting, the integral begins accumulating negative area (shown in red in our diagram). The positive and negative areas eventually balance out, and the system settles at zero error.</p>
<p>The most crucial insight about integral control is that it guarantees zero steady-state error. Here&rsquo;s why:</p>
<p><img src="/images/Pasted%20image%2020250413215100.png" alt="Image Description"></p>
<p>If a non-zero steady-state error were to exist, the integral term would continue accumulating indefinitely. The control signal would grow without bound, eventually becoming strong enough to move the system toward the reference.</p>
<p>This creates a mathematical paradox - with integral control, you simply cannot maintain a non-zero steady-state error indefinitely. The accumulated error would eventually produce a control signal strong enough to overcome any resistance in the system.</p>
<p>This is why integral control is essential for eliminating steady-state errors - it keeps &ldquo;pushing&rdquo; until the error becomes zero, no matter how small the error might be.</p>
<h2 id="derivative-control-explained">Derivative Control Explained</h2>
<p><img src="/images/Pasted%20image%2020250413220903.png" alt="Image Description">
<img src="/images/Pasted%20image%2020250413225647.png" alt="Image Description"></p>
<p>The derivative term examines the rate of change of the error: $K_d \frac{de(t)}{dt}$</p>
<p>Unlike the other terms, derivative control cannot operate effectively on its own and is typically combined with proportional control.</p>
<p>When analyzing a step change in our reference:</p>
<ol>
<li>Before the step, the derivative control output is zero since the error is constant (flat error = zero slope)</li>
<li>At the step itself, the slope is theoretically infinite, creating a large spike in the derivative output</li>
<li>As the error begins decreasing, the derivative term responds to the slope at each point</li>
</ol>
<p>Let&rsquo;s examine this in more detail. At point P1 in our diagram, the slope of the error is small, so the derivative contribution is small. At point P2, the slope is steeper, resulting in a larger derivative control signal. At point P3, where the slope is steepest, the derivative control reaches its maximum strength.</p>
<p>The most important characteristic of derivative control is that it becomes zero at steady state. Once the error stops changing (whether at zero or non-zero steady state), the derivative term contributes nothing to the control signal.</p>
<p>This is why derivative control doesn&rsquo;t help with steady-state error - it only comes into play when the error is actively changing. Its primary purpose is to provide damping during dynamic changes, reducing overshoot and improving stability.</p>
<h2 id="the-complete-pid-controller">The Complete PID Controller</h2>
<p><img src="/images/Pasted%20image%2020250413230346.png" alt="Image Description"></p>
<p>Now that we understand each term individually, let&rsquo;s see how they work together in a complete PID controller.</p>
<p>The proportional term provides an immediate response proportional to the current error. It forms the backbone of the controller but may result in steady-state error.</p>
<p>The integral term accumulates error over time, ensuring that even small persistent errors will eventually be corrected. This guarantees zero steady-state error but can introduce overshoot and oscillation.</p>
<p>The derivative term responds to the rate of change of error, providing a damping effect that can reduce overshoot and settling time. It helps stabilize the system during rapid changes but contributes nothing at steady state.</p>
<p>In a perfectly tuned system that has reached zero steady-state error:</p>
<ul>
<li>The proportional term becomes zero (since the error is zero)</li>
<li>The derivative term becomes zero (since the error is constant)</li>
<li>Only the integral term remains active, providing just enough control signal to maintain the desired output</li>
</ul>
<p>This interplay between the three components allows PID controllers to achieve excellent performance across a wide range of applications.</p>
<h2 id="practical-considerations">Practical Considerations</h2>
<p>While the theory above explains the fundamental operation of PID controllers, practical implementation involves careful tuning of the three gain parameters (Kp, Ki, and Kd). The optimal values depend on the specific characteristics of the system being controlled.</p>
<p>Too high a proportional gain can cause instability and oscillation. Too high an integral gain can cause excessive overshoot and slow recovery from disturbances. Too high a derivative gain can amplify noise and make the system overly sensitive to small changes.</p>
<p>The process of finding the right balance between these parameters is called PID tuning, which is both an art and a science in control engineering.</p>
<p>For a practical demonstration of PID control in action, I recommend watching <a href="https://youtu.be/_VzHpLjKeZ8?si=g_60MByeGy_GCVaE&amp;t=1840">this video</a> starting at the 30:40 mark, which shows how each component affects the behavior of a real system.</p>
<h2 id="bringing-it-all-together">Bringing It All Together</h2>
<p>PID controllers remain popular because they offer a remarkable balance of simplicity and effectiveness. With just three terms - proportional, integral, and derivative - we can create a controller that responds quickly to changes, eliminates steady-state error, and provides stable operation.</p>
<p>Understanding the individual contributions of each term helps engineers tune PID controllers for optimal performance in specific applications. Whether controlling temperature, position, speed, or countless other variables, the PID algorithm continues to be the cornerstone of modern control systems.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=_VzHpLjKeZ8&amp;t=49s">Understanding PID Control Systems</a></li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Understanding Incremental Rotary Encoders</title>
      <link>/posts/understanding-incremental-rotary-encoders/</link>
      <pubDate>Sat, 29 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>/posts/understanding-incremental-rotary-encoders/</guid>
      <description><![CDATA[<p>A <strong>rotary encoder</strong> is a device that converts the angular position of a shaft into analog or digital output signals. These encoders are commonly used in industrial automation, robotics, and consumer electronics.</p>
<h2 id="types-of-rotary-encoders">Types of Rotary Encoders</h2>
<p>There are two main types of rotary encoders:</p>
<h3 id="absolute-encoders">Absolute Encoders</h3>
<p>An <strong>absolute encoder</strong> maintains position information even when power is removed. It provides the current angular position of the shaft at any given moment.</p>
<h3 id="incremental-encoders">Incremental Encoders</h3>
<p>An <strong>incremental encoder</strong>, on the other hand, does not retain position information when powered off. It provides motion data based on changes from an initial reference point. To determine an absolute position, the system must first move to a known reference angle.</p>
<p>In this article, we will focus on <strong>incremental encoders</strong> and provide a simple ESP32 code to interface with them.</p>
<h2 id="how-incremental-encoders-work">How Incremental Encoders Work</h2>
<p>Incremental encoders have two main output signals:</p>
<ul>
<li><strong>A (Channel A)</strong></li>
<li><strong>B (Channel B)</strong></li>
</ul>
<p>These signals indicate movement and direction when the shaft rotates. Some encoders also include a third signal, <strong>Z</strong>, which serves as a reference point for position calibration.</p>
<h3 id="signal-representation">Signal Representation</h3>
<p>Here is an image illustrating signals <strong>A</strong>, <strong>B</strong>, and <strong>Z</strong>:</p>
<p><img src="/images/moving_disc_with_slits-1771498052.png" alt="Image Description"></p>
<h2 id="quadrature-outputs">Quadrature Outputs</h2>
<p>Incremental encoders employ a <strong>quadrature encoder</strong> to generate their <em>A</em> and <em>B</em> output signals. The pulses from these outputs are quadrature-encoded, meaning that <em>A</em> and <em>B</em> are phase-shifted by 90 degrees when the encoder moves at a constant speed.</p>
<p><img src="/images/Quadrature_Diagram.psd.png" alt="Image Description"></p>
<p>At any given moment, the phase difference between the <em>A</em> and <em>B</em> signals indicates the encoder&rsquo;s rotation direction:</p>
<ul>
<li>
<p>A phase difference of <strong>+90°</strong> corresponds to <strong>clockwise rotation</strong>.</p>
</li>
<li>
<p>A phase difference of <strong>−90°</strong> corresponds to <strong>counterclockwise rotation</strong>.</p>
</li>
</ul>
<p><img src="/images/quadrature-969270470.jpg" alt="Image Description"></p>
<p><img src="/images/Incremental_directional_encoder.gif" alt="Image Description"></p>
<h3 id="quadrature-encoding-table">Quadrature Encoding Table</h3>
<table>
  <thead>
      <tr>
          <th>Step</th>
          <th><code>outputA</code></th>
          <th><code>outputB</code></th>
          <th>Rotation Direction</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>LOW</td>
          <td>LOW</td>
          <td>Start Position</td>
      </tr>
      <tr>
          <td>2</td>
          <td>HIGH</td>
          <td>LOW</td>
          <td>Clockwise</td>
      </tr>
      <tr>
          <td>3</td>
          <td>HIGH</td>
          <td>HIGH</td>
          <td>Clockwise</td>
      </tr>
      <tr>
          <td>4</td>
          <td>LOW</td>
          <td>HIGH</td>
          <td>Clockwise</td>
      </tr>
      <tr>
          <td>5</td>
          <td>LOW</td>
          <td>LOW</td>
          <td>Next Step</td>
      </tr>
      <tr>
          <td>6</td>
          <td>LOW</td>
          <td>HIGH</td>
          <td>Counterclockwise</td>
      </tr>
      <tr>
          <td>7</td>
          <td>HIGH</td>
          <td>HIGH</td>
          <td>Counterclockwise</td>
      </tr>
      <tr>
          <td>8</td>
          <td>HIGH</td>
          <td>LOW</td>
          <td>Counterclockwise</td>
      </tr>
      <tr>
          <td>9</td>
          <td>LOW</td>
          <td>LOW</td>
          <td>Next Step</td>
      </tr>
  </tbody>
</table>
<h2 id="resolution-of-an-incremental-encoder">Resolution of an Incremental Encoder</h2>
<p>The <strong>resolution</strong> of an incremental encoder determines its precision. It is specified as:</p>
<ul>
<li><strong>Pulses per Revolution (PPR)</strong> for rotary encoders.</li>
<li><strong>Pulses per Unit Distance (e.g., mm)</strong> for linear encoders.</li>
</ul>
<p>Each signal edge (rising and falling transitions of <em>A</em> and <em>B</em>) represents a detected position change. Since each full cycle has four edges (rising <em>A</em>, rising <em>B</em>, falling <em>A</em>, falling <em>B</em>), the measurement resolution is <strong>one-fourth of a full <em>A</em> or <em>B</em> output cycle</strong>.</p>
<p>For example, a <strong>1000 pulse-per-revolution (PPR) rotary encoder</strong> has:</p>
<ul>
<li>Per-cycle measurement resolution = <strong>360° / 1000 cycles = 0.36° per pulse</strong></li>
<li>Effective resolution = <strong>0.36° / 4 = 0.09° per edge</strong></li>
</ul>
<h2 id="esp32-code-for-incremental-encoder">ESP32 Code for Incremental Encoder</h2>
<p>Below is a simple <strong>ESP32 Arduino</strong> code to read an incremental rotary encoder:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define outputA 17
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define outputB 16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> aLastState;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> IRAM_ATTR <span style="color:#a6e22e">handleEncoder</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> aState <span style="color:#f92672">=</span> digitalRead(outputA);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (aState <span style="color:#f92672">!=</span> aLastState) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (digitalRead(outputB) <span style="color:#f92672">!=</span> aState) {
</span></span><span style="display:flex;"><span>      counter<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      counter<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  aLastState <span style="color:#f92672">=</span> aState;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup</span>() {
</span></span><span style="display:flex;"><span>  pinMode(outputA, INPUT);
</span></span><span style="display:flex;"><span>  pinMode(outputB, INPUT);
</span></span><span style="display:flex;"><span>  Serial.begin(<span style="color:#ae81ff">9600</span>);
</span></span><span style="display:flex;"><span>  aLastState <span style="color:#f92672">=</span> digitalRead(outputA);
</span></span><span style="display:flex;"><span>  attachInterrupt(digitalPinToInterrupt(outputA), handleEncoder, CHANGE);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">loop</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> lastCounter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lastCounter <span style="color:#f92672">!=</span> counter) {
</span></span><span style="display:flex;"><span>    Serial.print(<span style="color:#e6db74">&#34;Position: &#34;</span>);
</span></span><span style="display:flex;"><span>    Serial.println(counter);
</span></span><span style="display:flex;"><span>    lastCounter <span style="color:#f92672">=</span> counter;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="why-use-an-interrupt-instead-of-digitalread-in-the-loop">Why Use an Interrupt Instead of <code>digitalRead</code> in the Loop?</h3>
<p>Using an <strong>interrupt function</strong> (<code>attachInterrupt</code>) allows the microcontroller to <strong>immediately detect</strong> changes in the encoder signal without continuously checking in the <code>loop()</code>. If we used <code>digitalRead</code> in the loop, we might miss some pulses, especially if the encoder rotates quickly. Interrupts ensure <strong>real-time response</strong> to changes in the encoder&rsquo;s state, leading to more accurate readings.</p>
<h3 id="understanding-volatile-and-iram_attr">Understanding <code>volatile</code> and <code>IRAM_ATTR</code></h3>
<ul>
<li>
<p><strong><code>volatile</code></strong>: This keyword tells the compiler that a variable can be modified by an interrupt, preventing optimization that might lead to incorrect behavior.</p>
</li>
<li>
<p><strong><code>IRAM_ATTR</code></strong>: This attribute ensures that the interrupt handler function (<code>handleEncoder</code>) is stored in <strong>IRAM (Instruction RAM)</strong> for faster execution, which is crucial for real-time processing.</p>
</li>
</ul>
<h3 id="why-cant-we-use-serialprint-in-handleencoder">Why Can&rsquo;t We Use <code>Serial.print</code> in <code>handleEncoder</code>?</h3>
<p>The <code>handleEncoder</code> function is an <strong>Interrupt Service Routine (ISR)</strong>, which should execute as quickly as possible. Using <code>Serial.print</code> inside an ISR can cause issues because:</p>
<ul>
<li><strong>Serial communication is slow</strong> compared to ISR execution speed.</li>
<li><strong>Serial functions use interrupts internally</strong>, which may conflict with the encoder ISR.</li>
<li><strong>Delays in ISR execution can cause missed pulses</strong>, leading to inaccurate readings.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Incremental rotary encoders are fundamental in position and motion sensing applications. Understanding how they generate quadrature signals allows precise control and tracking of rotary motion. With an ESP32 and a simple interrupt-driven approach, you can easily integrate an incremental encoder into your projects.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://howtomechatronics.com/tutorials/arduino/rotary-encoder-works-use-arduino/">https://howtomechatronics.com/tutorials/arduino/rotary-encoder-works-use-arduino/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rotary_encoder">https://en.wikipedia.org/wiki/Rotary_encoder</a></li>
<li><a href="https://en.wikipedia.org/wiki/Incremental_encoder">https://en.wikipedia.org/wiki/Incremental_encoder</a></li>
<li><a href="https://esp32io.com/tutorials/esp32-rotary-encoder">https://esp32io.com/tutorials/esp32-rotary-encoder</a></li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Charging the BYD Seagull: How 8A and 32A Chargers Impact Its LFP Battery</title>
      <link>/posts/charging-the-byd-seagull-how-8a-and-32a-chargers-impact-its-lfp-battery/</link>
      <pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate>
      
      <guid>/posts/charging-the-byd-seagull-how-8a-and-32a-chargers-impact-its-lfp-battery/</guid>
      <description><![CDATA[<p>The BYD Seagull is a compact electric vehicle equipped with lithium iron phosphate (LFP) batteries, known for their durability and thermal stability. Understanding how different charging rates affect these batteries is crucial for optimizing both vehicle performance and battery longevity.</p>
<h2 id="byd-seagulls-charging-capabilities">BYD Seagull&rsquo;s Charging Capabilities</h2>
<p>The Seagull offers two battery options: a 30.08 kWh LFP battery and a 38.88 kWh LFP BYD Blade battery. Its charging infrastructure supports:</p>
<ul>
<li><strong>AC Charging</strong>: Up to 6.6 kW</li>
<li><strong>DC Fast Charging</strong>: 30 kW or 40 kW</li>
</ul>
<p>These specifications indicate that the Seagull is designed to handle various charging scenarios, from standard home charging to faster public charging stations.</p>
<h2 id="understanding-c-rates-and-their-impact">Understanding C-Rates and Their Impact</h2>
<p>The C-rate measures the rate at which a battery is charged or discharged relative to its capacity. A 1C rate means charging the entire battery in one hour. For the Seagull&rsquo;s 30.08 kWh battery:</p>
<ul>
<li><strong>1C Rate</strong>: 30.08 kW</li>
<li><strong>0.5C Rate</strong>: 15.04 kW</li>
</ul>
<h2 id="charging-with-an-8a-charger">Charging with an 8A Charger</h2>
<p>An 8-ampere (A) charger operating at 230 volts (V) delivers approximately 1.84 kW (8A × 230V). This translates to a C-rate of about 0.061 for the 30.08 kWh battery (1.84 kW ÷ 30.08 kWh). Such a low C-rate is considered gentle on the battery, minimizing stress and potentially extending its lifespan.</p>
<h2 id="charging-with-a-32a-charger">Charging with a 32A Charger</h2>
<p>A 32A charger at 230V provides around 7.36 kW (32A × 230V). For the 30.08 kWh battery, this results in a C-rate of approximately 0.245 (7.36 kW ÷ 30.08 kWh). This rate is still within the battery&rsquo;s designed AC charging capacity of 6.6 kW, meaning the vehicle’s onboard charger will regulate the charging power accordingly.</p>
<h2 id="research-insights-on-lfp-batteries-and-charging-rates">Research Insights on LFP Batteries and Charging Rates</h2>
<p>Studies have shown that LFP batteries exhibit resilience to higher charging rates. For instance, research indicates that charging at rates up to 4C does not significantly impact the battery&rsquo;s lifespan. Specifically, capacity degradation was 15% at a 1C rate and 17% at a 4C rate after 4,000 cycles, with similar degradation observed up to 1,000 cycles.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The BYD Seagull&rsquo;s onboard charger supports a maximum AC charging power of 6.6 kW. This means that when using a 32A charger at 230V (which can provide up to approximately 7.36 kW), the vehicle&rsquo;s charging system will limit the power to 6.6 kW to stay within its designed capacity. Charging at this rate aligns with the vehicle&rsquo;s specifications and should not adversely affect the longevity of its lithium iron phosphate (LFP) battery. Therefore, utilizing a 32A charger is considered safe and appropriate for maintaining the battery&rsquo;s health.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/BYD_Seagull">https://en.wikipedia.org/wiki/BYD_Seagull</a></li>
<li><a href="https://findingspress.org/api/v1/articles/21459-impact-of-charging-rates-on-electric-vehicle-battery-life.pdf">https://findingspress.org/api/v1/articles/21459-impact-of-charging-rates-on-electric-vehicle-battery-life.pdf</a></li>
<li><a href="https://moscow.sci-hub.ru/5155/011d5b81780c4ac3e787a937c78bd05a/10.1016@j.jpowsour.2016.04.140.pdf">https://moscow.sci-hub.ru/5155/011d5b81780c4ac3e787a937c78bd05a/10.1016@j.jpowsour.2016.04.140.pdf</a></li>
<li><a href="https://acmobility.ph/news/byd-seagull-launch">https://acmobility.ph/news/byd-seagull-launch</a></li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Fixing My Ethernet Cable Issue</title>
      <link>/posts/fixing-my-ethernet-cable-issue/</link>
      <pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate>
      
      <guid>/posts/fixing-my-ethernet-cable-issue/</guid>
      <description><![CDATA[<h2 id="the-setup">The Setup</h2>
<p>My father brought an electrician home to wire an Ethernet cable from the router to my room. He ran the cable inside the wall, and everything seemed fine at first. However, when he crimped the RJ-45 connectors, he messed up, and the cable wasn’t working on my laptop. That meant I had to fix it myself.</p>
<p>To do this, I needed:</p>
<ul>
<li>An Ethernet cable tester</li>
<li>An Ethernet crimper</li>
<li>RJ-45 plugs</li>
</ul>
<p>Here’s a photo of each item:</p>
<p><img src="/images/Drawing%202025-02-28%2005.37.43.excalidraw.png" alt="Image Description"></p>
<h2 id="understanding-the-ethernet-cable-tester">Understanding the Ethernet Cable Tester</h2>
<p>Before jumping in, I had to figure out how the Ethernet cable tester actually works. I watched a few YouTube videos and learned that it’s just a connectivity tester. An Ethernet cable has eight wires, and the tester checks each one sequentially. If the wire is properly connected, its corresponding LED blinks. If an LED doesn’t blink, that wire isn’t connected properly, meaning the cable is faulty.</p>
<p>To get comfortable with the tester, I tried it on an already working cable.</p>
<p><img src="/images/IMG-20250228-WA0021.jpg" alt="Image Description"></p>
<p>The LED numbers correspond to the pin numbers in the RJ-45 plug. Here’s an image showing the correct pin numbering:</p>
<p><img src="/images/wmremove-transformed.png" alt="Image Description"></p>
<h2 id="diagnosing-the-issue">Diagnosing the Issue</h2>
<p>Now that I understood how the tester works, I tested the cable the electrician installed. I connected the first part of the tester in the living room and the second part in my bedroom.</p>
<p><img src="/images/Pasted%20image%2020250228061200.png" alt="Image Description"></p>
<p>Here’s a video showing that all LEDs turned on except for number 7. That’s why the cable wasn’t working.</p>
<p><img src="/images/Timeline%201%201.gif" alt="Image Description"></p>
<h2 id="fixing-the-ethernet-cable">Fixing the Ethernet Cable</h2>
<p>To fix the issue, I had to replace the RJ-45 connectors on both ends of the cable. Initially, I only replaced the end in the living room and tested it again. If that fixed the issue, I wouldn’t need to replace the bedroom end. But in the end, I had to change both.</p>
<p>Here’s the YouTube video that helped me with the process: <a href="https://youtu.be/T1Cp9F8qto8?si=mocguZS7ddZXiqb7">Watch it here</a>.</p>
<h3 id="replacing-the-rj-45-plug">Replacing the RJ-45 Plug</h3>
<h4 id="step-1-cutting-the-old-rj-45-plug">Step 1: Cutting the Old RJ-45 Plug</h4>
<p><img src="/images/IMG-20250228-WA0011.jpg" alt="Image Description"></p>
<h4 id="step-2-removing-the-outer-plastic-sheath">Step 2: Removing the Outer Plastic Sheath</h4>
<p><img src="/images/IMG-20250228-WA0007.jpg" alt="Image Description"></p>
<h4 id="step-3-untwisting-the-wires-and-cutting-excess-plastic">Step 3: Untwisting the Wires and Cutting Excess Plastic</h4>
<p><img src="/images/IMG-20250228-WA0006.jpg" alt="Image Description"></p>
<h4 id="step-4-arranging-the-wires-in-the-correct-order">Step 4: Arranging the Wires in the Correct Order</h4>
<p>The correct color order follows the T568A standard:</p>
<p><img src="/images/T568Aworking-3434845376.png" alt="Image Description"></p>
<p>Here’s how it looked after arranging them:</p>
<p><img src="/images/IMG-20250228-WA0004.jpg" alt="Image Description"></p>
<h4 id="step-5-cutting-and-crimping-the-wires">Step 5: Cutting and Crimping the Wires</h4>
<p>After cutting the wires to the correct length, I used the crimper to attach the new RJ-45 plug.</p>
<p>Here’s the final result:</p>
<p><img src="/images/IMG-20250228-WA0001.jpg" alt="Image Description"></p>
<p>I repeated the same process in my bedroom:</p>
<p><img src="/images/IMG-20250228-WA0002.jpg" alt="Image Description"></p>
<h2 id="testing-the-fixed-cable">Testing the Fixed Cable</h2>
<p>I tested the cable again using the tester.</p>
<p>Now, it was time for the moment of truth. I tested the cable one more time using the Ethernet tester, and…</p>
<p><img src="/images/Timeline%202.gif" alt="Image Description"></p>
<p>Success! The tester confirmed that all the LEDs were lighting up correctly.</p>
<p>To be completely sure, I connected one end to the router and the other to my laptop. It worked!</p>
<p><img src="/images/WhatsApp%20Image%202025-02-28%20at%2006.57.16_a9c1cdcd.jpg" alt="Image Description"></p>
<h3 id="conclusion">Conclusion</h3>
<p>This was a fun hands-on experience, and I learned a lot about networking cables, testers, and crimping RJ-45 connectors. Hopefully, this helps anyone dealing with similar issues!</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Understanding UART and Serial Communication</title>
      <link>/posts/understanding-uart-and-serial-communication/</link>
      <pubDate>Fri, 14 Feb 2025 00:00:00 +0000</pubDate>
      
      <guid>/posts/understanding-uart-and-serial-communication/</guid>
      <description><![CDATA[<h1 id="data-transmission">Data Transmission</h1>
<p>Data transmission can be categorized into two main types: <strong>Serial</strong> and <strong>Parallel</strong>. Serial communication, in particular, has several subtypes, including <strong>Asynchronous</strong>, <strong>Synchronous</strong>, and <strong>Isochronous</strong>. In this post, we’ll focus on <strong>UART (Universal Asynchronous Receiver-Transmitter)</strong>, which is an asynchronous method of communication. Unlike synchronous communication, UART does not require devices to share the same clock cycles or be synchronized.</p>
<p><img src="/images/Data%20transmission.png" alt="Image Description"></p>
<hr>
<h2 id="serial-vs-parallel-transmission">Serial vs. Parallel Transmission</h2>
<ul>
<li>
<p><strong>Serial Transmission</strong>: Data is sent one bit at a time over a single communication channel. This method is simpler and more cost-effective but can be slower compared to parallel transmission.</p>
</li>
<li>
<p><strong>Parallel Transmission</strong>: Data is sent in groups of 8 bits (a byte) simultaneously over multiple channels. While faster, it is more complex and expensive due to the need for multiple communication lines.</p>
</li>
</ul>
<p>Both methods enable devices to communicate, but they differ in their approach. Serial transmission is often preferred for its simplicity and lower cost, while parallel transmission is used when speed is critical.</p>
<p><img src="/images/parallel%20vs%20serail.png" alt="Image Description"></p>
<h3 id="key-terms">Key Terms:</h3>
<ul>
<li><strong>MSB (Most Significant Bit)</strong>: The bit with the highest value in a byte (e.g., 2^7).</li>
<li><strong>LSB (Least Significant Bit)</strong>: The bit with the lowest value in a byte (e.g., 2^0).</li>
</ul>
<hr>
<h2 id="serial-transmission">Serial Transmission</h2>
<p>In serial transmission, bits are sent one after another over a single communication channel. This reduces the cost of transmission compared to parallel methods, which require multiple channels. Serial transmission can be implemented in three ways: <strong>asynchronous</strong>, <strong>synchronous</strong>, and <strong>isochronous</strong>.</p>
<hr>
<h3 id="asynchronous-transmission-uart">Asynchronous Transmission (UART)</h3>
<p>Asynchronous transmission does not rely on a shared clock signal between devices. Instead, it uses agreed-upon patterns to communicate data. Each byte of data is framed with a <strong>start bit</strong> and one or more <strong>stop bits</strong>, allowing the receiver to identify the beginning and end of each byte.</p>
<ul>
<li><strong>Start Bit</strong>: A single bit (usually 0) that signals the start of a byte.</li>
<li><strong>Stop Bit(s)</strong>: One or more bits (usually 1s) that signal the end of a byte.</li>
</ul>
<p>Between bytes, there may be a gap or idle time, which helps the receiver prepare for the next byte. The receiver synchronizes with the incoming data stream at the start of each byte, ensuring accurate data interpretation.</p>
<blockquote>
<p><strong>Note</strong>: Asynchronous transmission is &ldquo;asynchronous at the byte level,&rdquo; but the bits within each byte are still synchronized.</p>
</blockquote>
<p><img src="/images/serial%20byte.png" alt="Image Description"></p>
<hr>
<h2 id="uart-universal-asynchronous-receiver-transmitter">UART: Universal Asynchronous Receiver-Transmitter</h2>
<p>UART is a hardware device that facilitates asynchronous serial communication. It uses two wires:</p>
<ul>
<li><strong>Tx (Transmit)</strong>: Sends data from the transmitting device.</li>
<li><strong>Rx (Receive)</strong>: Receives data at the receiving device.</li>
</ul>
<p><img src="/images/Pasted%20image%2020250215052600.png" alt="Image Description"></p>
<p>The communication speed, known as the <strong>baud rate</strong>, must be agreed upon by both devices.</p>
<hr>
<h3 id="baud-rate-how-it-works">Baud Rate: How It Works</h3>
<p>The <strong>baud rate</strong> is a critical parameter in serial communication, especially in UART. It defines the speed at which data is transmitted and received, measured in <strong>bits per second (bps)</strong>. Here’s how it works:</p>
<ol>
<li>
<p><strong>Definition</strong>: The baud rate represents the number of signal changes (symbols) per second. In UART, each symbol typically corresponds to one bit, so the baud rate is often equal to the bit rate.</p>
</li>
<li>
<p><strong>Synchronization</strong>: Both the transmitter and receiver must be configured to use the same baud rate. If they are not synchronized, data will be misinterpreted, leading to communication errors.</p>
</li>
<li>
<p><strong>Common Baud Rates</strong>: Some standard baud rates include 9600, 19200, 38400, 57600, and 115200 bps. Lower baud rates are used for longer distances or noisy environments, while higher baud rates are used for faster communication over shorter distances.</p>
</li>
<li>
<p><strong>Calculation</strong>: The baud rate determines the duration of each bit. For example, at 9600 bps, each bit lasts approximately 104 microseconds (1 second / 9600 bits).</p>
</li>
<li>
<p><strong>Error Tolerance</strong>: The receiver samples the incoming data at the midpoint of each bit. If the baud rates of the transmitter and receiver are slightly mismatched, the sampling point may drift, causing errors. Therefore, precise baud rate configuration is essential.</p>
</li>
</ol>
<hr>
<h3 id="ttl-vs-rs-232">TTL vs. RS-232</h3>
<h4 id="ttl-transistor-transistor-logic">TTL (Transistor-Transistor Logic):</h4>
<ul>
<li>Operates at 5V.</li>
<li>Commonly used in short-range communication.</li>
<li>Not a protocol but refers to the voltage level used by UART.</li>
<li>Example: USB-to-TTL converters.</li>
</ul>
<p><img src="/images/TTL.png" alt="Image Description"></p>
<h4 id="rs-232">RS-232:</h4>
<ul>
<li>Uses higher voltage levels (+/- 12V) for long-range communication.</li>
<li>Voltage levels:
<ul>
<li>-3V to -15V represents a &ldquo;1&rdquo; bit.</li>
<li>+3V to +15V represents a &ldquo;0&rdquo; bit.</li>
</ul>
</li>
<li>Active low logic.</li>
</ul>
<p><img src="/images/RS232.png" alt="Image Description"></p>
<hr>
<h3 id="references">References:</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=JuvWbRhhpdI">YouTube: UART Communication Explained</a></li>
<li><a href="https://www.youtube.com/watch?v=IyGwvGzrqp8">YouTube: Serial vs. Parallel Communication</a></li>
<li><a href="https://www.youtube.com/watch?v=V6m2skVlsQI">YouTube: TTL and RS-232 Explained</a></li>
<li><a href="https://www.youtube.com/watch?v=4xBjrE9csxg">YouTube: Asynchronous Transmission</a></li>
<li><a href="https://www.youtube.com/watch?v=Z-O6PkvYXXs">YouTube: UART Protocol Deep Dive</a></li>
<li><a href="https://dpvipracollege.in/wp-content/uploads/2023/01/Data-Communications-and-Networking-By-Behrouz-A.Forouzan.pdf">Data Communications and Networking by Behrouz A. Forouzan</a></li>
<li><a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">Wikipedia: Universal Asynchronous Receiver-Transmitter</a></li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Understanding Capacitor Charging and the Concept of Full Charge</title>
      <link>/posts/understanding-capacitor-charging-and-the-concept-of-full-charge/</link>
      <pubDate>Mon, 20 Jan 2025 00:00:00 +0000</pubDate>
      
      <guid>/posts/understanding-capacitor-charging-and-the-concept-of-full-charge/</guid>
      <description><![CDATA[<p>While taking a <a href="https://youtube.com/playlist?list=PLww54WQ2wa5qVh1p8iPi7HspX7N9hbvbc&amp;si=9h1KH2NZG2lSLsaB">course with Walid Issa</a>, we explored the fascinating behavior of capacitors. During one of the experiments, an interesting observation about capacitor charging sparked my curiosity. My friend <a href="https://www.linkedin.com/in/ahmad-awad-36b481301/">Ahmad Awad</a> and I decided to dive deeper into the topic, conducting research that ultimately led to this blog.</p>
<p>When analyzing capacitors, we often hear that a capacitor is &ldquo;fully charged&rdquo; when the elapsed time equals 5 times the time constant (“5τ”). However, upon closer look, this statement needs some clarification. Let&rsquo;s dive into the theory, practical observations, and what &ldquo;fully charged&rdquo; really means.</p>
<h2 id="observations-from-the-simulation">Observations from the Simulation</h2>
<p><img src="/images/Pasted%20image%2020250121022953.png" alt="Image Description">
<img src="/images/Pasted%20image%2020250121023020.png" alt="Image Description"></p>
<p>In a recent calculation, the capacitor was expected to be fully charged in 0.25 seconds. However, the voltage across the capacitor at this point was 11.923 V instead of the expected 12 V. The error was calculated as:</p>
<p>$$ \frac{12 - 11.923}{12} \times 100 = 0.6% $$</p>
<p>This raised the question: Why is there an error when the capacitor is supposed to be fully charged at 5τ?</p>
<h2 id="the-truth-about-5τ">The Truth About 5τ</h2>
<p>The value of 5τ does not mean the capacitor is 100% charged. Instead, it means the capacitor has reached about 99.3% of its maximum voltage. Using the data from the simulation, we can confirm this:</p>
<p>$$ \frac{11.923}{12} \times 100 = 99.33% $$</p>
<p>This matches the theoretical prediction. While the capacitor seems nearly charged at 5τ, it never fully reaches 100% because of the exponential nature of its charging curve.</p>
<h2 id="theoretical-explanation">Theoretical Explanation</h2>
<p><img src="/images/Pasted%20image%2020250121015614.png" alt="Image Description"></p>
<p>The voltage across a charging capacitor is given by the equation:</p>
<p>$$ V(t) = V_{\text{max}} \left( 1 - e^{-\frac{t}{RC}} \right) $$</p>
<p>where:</p>
<ul>
<li>Vmax is the maximum voltage the capacitor can charge to (12 V in this case).</li>
<li>t is the time elapsed.</li>
<li>RC is the time constant of the circuit.</li>
</ul>
<p>As time passes, $$e^{-t/RC}$$ gets closer to zero.</p>
<p><img src="/images/Pasted%20image%2020250121015737.png" alt="Image Description">
This means it would take infinite time for the capacitor to reach exactly Vmax. In practice, we consider the capacitor &ldquo;fully charged&rdquo; when it’s close enough to Vmax, such as 99.3% at 5τ.</p>
<h2 id="the-simulation-discrepancy">The Simulation Discrepancy</h2>
<p><img src="/images/Pasted%20image%2020250121020039.png" alt="Image Description"></p>
<p>Interestingly, the simulation showed the capacitor reaching exactly 12 V, which seems to go against the theory. Why did this happen?</p>
<ol>
<li><strong>Oscilloscope Precision:</strong> Oscilloscopes show voltages with limited precision. If the capacitor voltage is extremely close to the maximum (e.g., 11.999999 V), the oscilloscope rounds it to 12 V.</li>
<li><strong>Rounding Effects:</strong> The actual voltage might still be slightly below 12 V, but the measuring device’s resolution hides these small differences. Higher-resolution equipment would show the tiny gap.</li>
</ol>
<h2 id="key-takeaways">Key Takeaways</h2>
<ul>
<li>At 5τ, a capacitor is 99.3% charged, not 100%.</li>
<li>It would take infinite time for a capacitor to reach exactly $Vmax$.</li>
<li>Simulations and measurements often show Vmax due to rounding and device limitations.</li>
<li>This approximation is fine for real-world use, as the difference is too small to matter.</li>
</ul>
<p>Understanding these details gives a clearer picture of how capacitors behave and avoids common misunderstandings about what &ldquo;fully charged&rdquo; means.</p>
]]></description>
      
    </item>
    
    
  </channel>
</rss>
